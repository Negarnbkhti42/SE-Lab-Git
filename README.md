# آزمایشگاه مهندسی نرم افزار - مدیریت نسخ پروژه و یکپارچه‌سازی مستمر

در این مخزن در حین پیاده‌سازی یک نسخه ساده از بازی wordle اهداف آزمایش اول مهندسی نرم‌افزار را برای یادگیری استفاده از ابزار git برآورده می‌کنیم.

## ایجاد مخزن

پیش از شروع پروژه لازم است مخزن خود را با استفاده از دستور `git init` به صورت محلی ایجاد کنیم.

![init local repo](./assets/Screen%20Shot%202023-10-22%20at%2010.32.09%20PM.png)

در ادامه مخزنی را در github.com ایجاد کرده و آدرس آن را به عنوان `remote` برای مخزن محلی تعریف می‌کنیم.

## حفاظت از شاخه main

برای حفاظت از شاخه main خود، قوانینی را برای آن تعیین می‌کنیم. در تنظیمات مربوط به مخزن برای شاخه main این محدودیت را تعریف می‌کنیم که تنها با استفاده از `pull request` و تایید یک نفر می‌توان چیزی به آن commit کرد.

![go to branch settings](./assets/Screen%20Shot%202023-10-22%20at%2010.50.00%20PM.png)

![add rule for main branch](./assets/Screen%20Shot%202023-10-30%20at%209.28.09%20PM.png)

در هنگام ایجاد یک `pull request` با مقصد main نیز می‌توان مشاهده کرد که تنها با approve یک شخص دیگر اجازه emrge داده می‌شود.

![merge request only on approve](./assets/Screen%20Shot%202023-10-22%20at%2010.51.55%20PM.png)

## اضافه کردن gitignore

فایل `.gitignore` را برای در نظر نگرفتن تغییرات در پوشه `.vscode` که تنظیمات IDE را در خود دارد ایجاد می‌کنیم. پس از ایجاد این فایل آدرس مورد نظر خود را در آن وارد و فایل را push می‌کنیم.

![add gitignore](./assets/Screen%20Shot%202023-10-25%20at%203.40.46%20PM.png)

## رفع conflict

در طول پیاده سازی پروژه، دو شاخه ایجاد شدند که در یکی از آنها منطق جمع آوری کلمات از یک فایل متنی، و در دیگری یک رابط کاربری متنی ساده پیاده سازی شده بود. در ادامه قصد داشتیم این دو شاخه با یکدیگر merge کنیم. برای اینکار ابتدا یک pull request در گیت‌هاب ایجاد کردیم. اما متوجه شدیم که دو شاخه با یکدیگر conflict دارند.

![pull request in github](./assets/Screen%20Shot%202023-10-27%20at%203.06.51%20PM.png)

برای رفع آن، سعی کردیم دو شاخه را به صورت محلی با یکدیگر merge کنیم.

![merge local conflict](./assets/Screen%20Shot%202023-10-27%20at%203.19.48%20PM.png)

با ایجاد emrge conflict، فایلی که در آن conflict ایجاد شده را در یک ویرایشگر باز کرده و آن را رفع کردیم.

![merge local conflict](./assets/Screen%20Shot%202023-10-27%20at%203.20.21%20PM.png)

و تغییرات پس از merge را commit کردیم.

![merge local conflict](./assets/Screen%20Shot%202023-10-27%20at%203.24.09%20PM.png)

## پاسخ پرسش‌ها

1. **پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟**

پوشه .git پوشه‌ای است که با استفاده از دستور `git init` ساخته می‌شود و شامل تمامی اطلاعاتی است که گیت نیاز دارد تا مسیر تغییرات پروژه را ردیابی کند. از جمله کامیت‌ها، آدرس مخزن ریموت، و لاگ‌ها

2. **منظور از atomic بودن در atomic commit و atomic pull-request چیست؟**

اتمیک بودن یک کامیت بدین معناست که هر کامیت تنها حاوی یک نوع عملیات باشد. برای مثال یک کامیت تنها باید شامل تغییراتی مربوط به اصلاح یک باگ یا اضافه کردن یک قابلیت جدید باشد.

منظور از اتمیک بودن pull-requestاین است که تمامی تغییرات موجود در آن مربوط به یک مساله باشند. اگر تغییری (هر چند کوچک، مانند عوض کردن نام یک متغیر) به مساله مورد نظر مربوط نباشد، باید آن را در pull request دیگری قرار داد.

3. **تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.**

- merge: این دستور برای ادغام دو شاخه که بر روی یک سیستم در دسترس هستند استفاده می‌شود.

- fetch: از این دستور برای دریافت تغییرات در مخزن ریموت استفاده می‌شود. تغییرات دریافت شده در شاخه‌هایی به جز شاخه‌هایی که به صورت محلی تغییر داده شده‌اند. قرار می‌گیرند.

- pull: کاری که این دستور انجام می‌دهد خلاصه شده دو دستور قبلی است. بدین معنی که در صورت اجرای این دستور، ابتدا تغییرات را از مخزن ریموت دریافت می‌کند و سپس تغییرات شاخه ریموت را با شاخه محلی ادغام می‌کند.

- rebase: با استفاده از این دستور می‌توان در مجموعه‌ای از کامیت‌ها تغییر ایجاد کرد، به طوری که تاریخچه تغییرات پروژه تغییر کنند. به عنوان مثال، می‌توان ترتیب کامیت‌ها را عوض کرد، آنها را ادغام کرد (چند کامیت را به یک کامیت تبدیل می‌کند) یا آنها را ویرایش کرد.

یکی از استفاده‌های اصلی rebase در منتقل کردن تغییرات یک شاخه به یک شاخه دیگر است. تفاوت این دستور با merge در این است که rebase merge در هنگام ادغام با یک شاخه مقصد، تاریخه و لاگ‌های شاخه مبدا را نگه‌می‌دارد. اما rebase اطلاعات شاخه را تمام منتقل می‌کند و تاریخچه پروژه را تغییر می‌هد. طوری که به نظر می‌رسد تغییرات از همان ابتدا بر روی شاخه مقصد اعمال شده بودند.

- cherry-pick: با استفاده از این دستور می‌توان یک کامیت را جا به جا کرد و در شاخه دیگری قرار دارد. استفاده از این دستور هنگامی که به اشتباه کامیتی را در شاخه دیگری انجام می‌دهیم می‌تواند مفید باشد. این کامیت می‌تواند در هر جایی از شاخه قرار داشته باشد.

4. **تفاوت دستورهای reset و revert و restore را بیان کنید.**

هر سه این دستورات برای خنثی کردن برخی تغییرات در پروژه استفاده می‌شوند. تفاوت آنها در این است که:

- با استفاده از `reset` می‌توان کامیت‌هایی را حذف کرد. کامیت‌های حذف شده به صورت کامل از تاریخچه پروژه پاک می‌شوند و دیگر نمی‌توان به آن‌ها دسترسی داشت.

- با استفاده از `revert` می‌توان تعدادی از کامیت‌ها را از پروژه حذف کرد. با این تفاوت که عمل حذف کامیت‌ها و تغییرات ایجاد شده بر اثر آن به صورت یک کامیت جدید در پروژه ذخیره می‌شود و می‌تواند مجددا به کامیت‌های حذف شده دسترسی داشت.

- برخلاف دو دستور قبلی، دستور `restore` تغییرات بخش staging را حذف می‌کند و فایل‌های پروژه را به آخرین نسخه کامیت‌ شده بازمی‌گرداند. البته روی فایل‌هایی که جدیدا ایجاد شده باشند اثر ندارد.

5. **منظور از stage چیست؟ دستور stash چه کاری را انجام می‌دهد؟**

پیش از آنکه بخواهیم در گیت کامیتی انجام دهیم، باید مشخص کنیم که چه فایل‌های تغییر یافته، اضافه شده یا حذف شده را می‌خواهیم در این کامیت قرار دهیم. فایل‌های مورد نظر با کمک دستور `add` به اصطلاح stage می‌شوند. در هر کامیت تنها این فایل‌های stage شده در کامیت قرار می‌گیرند.

دستور `stash` تغییرات کامیت نشده را در فضایی موقت ذخیره می‌کند تا در صورت نیاز در جایی دیگری محددا آنها را به پروژه اضافه کند. استفاده از این دستور در مواقعی که می‌خواهیم به کار دیگری بپردازیم، اما تغییرات فعلی ما آماده کامیت نیستند کاربرد دارد.

6. **مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟**

مفهوم snapshot به معنای وضعیت فعلی فایل‌های ردیابی شده در هر لحظه ست. هنگامی که در یک مخزن کامیتی انجام می‌دهیم، در حقیقت یک snapshot از تمامی محیط می‌گیریم. هنگام ذخیره کامیت‌ها، گیت تغییرات تک تک فایل‌ها را جدا ذخیره نمی‌کند، بلکه کلیت snapshot را ذخیره می‌کند.
